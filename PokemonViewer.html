<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - OBJLoader + MTLLoader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                /*background-color: black;*/
                margin-left: 0;
                padding-left: 0;
            }
        </style>
    </head>

    <body>
        <script src="js/libs/three.js"></script>

        <script src="js/loaders/DDSLoader.js"></script>
        <script src="js/loaders/MTLLoader.js"></script>
        <script src="js/loaders/OBJLoader.js"></script>
        <!-- <script src="js/libs/stats.js"></script> -->

        <script>

            var container;

            var camera, scene, renderer, mainScene, mainCamera;

            // var stats, lastTime=0, now;

            var mouseX = 0, mouseY = 0;

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;
            var windowWidth, windowHeight;

            var cameraDistance_y = 4;
            var cameraDistance_xz = 7;
            var cameraLookPos = new THREE.Vector3(0,3,0);

            //lenght is 4  in this program(front, right, back and left view)
            var renderTarget = [];
            var planeMat = [];
            var texSize = 100;
            var attachTextureGeometry = [];
            var mainMeshes = [];
            var obj;

            var views = [
                {
                    eye: [ 0, cameraDistance_y, cameraDistance_xz ],
                    up: [ 0, 1, 0 ],
                    fov: 45,                    
                },
                {
                    eye: [ cameraDistance_xz, cameraDistance_y, 0 ],
                    up: [ 0, 1, 0 ],
                    fov: 45,
                },
                {
                    eye: [ 0, cameraDistance_y, -cameraDistance_xz ],
                    up: [ 0, 1, 0 ],
                    fov: 45,
                },
                {
                    eye: [ -cameraDistance_xz, cameraDistance_y, 0 ],
                    up: [ 0, 1, 0 ],
                    fov: 45,                    
                }
            ];

            init();
            animate();


            function init() {

                // container = document.createElement( 'div' );
                // document.body.appendChild( container );

                //culculate the size of maximum square
                var size = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth;
                windowWidth  = size;
                windowHeight = size;

                // scene
                scene = new THREE.Scene();

                for (var ii =  0; ii < views.length; ++ii ) {
                    var view = views[ii];
                    camera = new THREE.PerspectiveCamera( view.fov, windowWidth / windowHeight, 1, 100);
                    camera.position.x = view.eye[ 0 ];
                    camera.position.y = view.eye[ 1 ];
                    camera.position.z = view.eye[ 2 ];
                    camera.up.x = view.up[ 0 ];
                    camera.up.y = view.up[ 1 ];
                    camera.up.z = view.up[ 2 ];
                    camera.aspect = windowWidth / windowHeight;
                    camera.lookAt(cameraLookPos);
                    view.camera = camera;
                }

                //light

                var ambient = new THREE.AmbientLight( 0x444444 );
                scene.add( ambient );

                var directionalLight = new THREE.DirectionalLight( 0xffeedd );
                directionalLight.position.set( 0, 1, 1 ).normalize();
                scene.add( directionalLight );


                var directionalLight2 = new THREE.DirectionalLight( 0xffeedd );
                directionalLight2.position.set( 0, 1, -1 ).normalize();
                scene.add( directionalLight2 );

                // model

                var onProgress = function ( xhr ) {
                    if ( xhr.lengthComputable ) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log( Math.round(percentComplete, 2) + '% downloaded' );
                    }
                };

                var onError = function ( xhr ) { };

                THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );

                var mtlLoader = new THREE.MTLLoader();
                mtlLoader.setPath( 'Pikachu/' );
                mtlLoader.load( 'Pikachu.mtl', function( materials ) {

                    materials.preload();

                    var objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials( materials );
                    objLoader.setPath( 'Pikachu/' );
                    objLoader.load( 'Pikachu.obj', function ( object ) {
                        obj = object;
                        obj.position.y = 0;
                        scene.add( obj );

                    }, onProgress, onError );
                    // console.log(objLoader);

                });

                //

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( windowWidth, windowHeight );
                // container.appendChild( renderer.domElement );
                document.body.appendChild( renderer.domElement );


                //ivent listener
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );


                //setting of texxture rendering
                for (var i = 0; i < views.length; i++) {
                    renderTarget[i] = new THREE.WebGLRenderTarget(texSize, texSize, {
                         magFilter: THREE.NearestFilter,
                         minFilter: THREE.NearestFilter,
                         wrapS: THREE.ClampToEdgeWrapping,
                         wrapT: THREE.ClampToEdgeWrapping
                    });

                    planeMat[i] = new THREE.MeshLambertMaterial({
                        color: 0xffffff,
                        map: renderTarget[i]                    
                    });

                    attachTextureGeometry[i] = new THREE.PlaneGeometry(texSize, texSize, 1, 1);

                    mainMeshes[i] = new THREE.Mesh(attachTextureGeometry[i], planeMat[i]);
                }

                //main rendering
                mainScene = new THREE.Scene();

                mainCamera = new THREE.OrthographicCamera(-texSize*3/2, texSize*3/2, texSize*3/2, -texSize*3/2, 1, 2);
                mainCamera.position.set(0, 1, 0);
                mainCamera.up.x = 0;
                mainCamera.up.y = 0;
                mainCamera.up.z = -1;
                mainCamera.lookAt(mainScene.position);
                // camera.lookAt(mainScene.position);

                mainMeshes[0].position.set(0, 0, texSize);
                mainMeshes[1].position.set(texSize, 0, 0);
                mainMeshes[2].position.set(0, 0, -texSize);
                mainMeshes[3].position.set(-texSize, 0, 0);


                for (var i = 0; i < views.length; i++) {
                    
                    mainMeshes[i].rotation.x = Math.PI / -2;
                    mainScene.add(mainMeshes[i]);
                }

                mainMeshes[1].rotation.z = Math.PI / 2;
                mainMeshes[2].rotation.z = Math.PI;
                mainMeshes[3].rotation.z = Math.PI / -2;

                
                var mainLight = new THREE.DirectionalLight( 0xffffff);
                mainLight.position.set( 0, 50, 0);
                mainLight.target.position.copy( mainScene.position );

                mainScene.add(mainLight);

                // stats = new Stats();


            }

            function onDocumentMouseMove( event ) {

                mouseX = ( event.clientX - windowHalfX ) / 2;
                mouseY = ( event.clientY - windowHalfY ) / 2;

            }

            //

            function animate() {

                requestAnimationFrame( animate );
                renderToTexture();
                renderer.render(mainScene, mainCamera);

            }

            function renderToTexture() {
                // stats.update();
                // var fps = stats.getFps();
                // console.log(fps);
                // if (fps != 0) obj.rotation.y += 2*Math.PI/30 / fps;
                // console.log(obj.rotation.y);                
                for ( var ii = 0; ii < views.length; ++ii ) {
                    view = views[ii];
                    camera = view.camera;
                    // camera.position.x += ( mouseX - camera.position.x ) * .05;
                    // camera.position.y += ( - mouseY - camera.position.y ) * .05;
                    // camera.lookAt( scene.position);
                    mainMeshes[ii].material.needsUpdate = true;
                    renderer.render( scene, camera, renderTarget[ii] );   
                }
            }


        </script>

    </body>
</html>
